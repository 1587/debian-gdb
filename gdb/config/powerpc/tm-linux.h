/* Definitions to target GDB to Linux on 386.
   Copyright 1992, 1993 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef TM_LINUX_H
#define TM_LINUX_H

#include "powerpc/tm-ppc-eabi.h"

/* We can single step on linux */
#undef  SOFTWARE_SINGLE_STEP
#define SOFTWARE_SINGLE_STEP(p,q) abort() /* Will never execute! */
#undef  SOFTWARE_SINGLE_STEP_P
#define SOFTWARE_SINGLE_STEP_P 0

/* Make sure nexti gets the help it needs for debugging assembly code
   without symbols */

#define AT_SUBROUTINE_CALL_INSTRUCTION_TARGET(prevpc,stoppc) \
   at_subroutine_call_instruction_target(prevpc,stoppc)
extern int at_subroutine_call_instruction_target();

/* We _want_ the SVR4 section offset calculations (see syms_from_objfile()
   in symfile.c) */
#undef IBM6000_TARGET

/* Offset to saved PC in sigcontext, from <linux/signal.h>.  */
#define SIGCONTEXT_PC_OFFSET 184

/* Avoid warning from redefinition in tm-sysv4.h */
#undef SKIP_TRAMPOLINE_CODE

/* We need this file for the SOLIB_TRAMPOLINE stuff. */
#include "tm-sysv4.h"

/* BREAKPOINT_FROM_PC uses the program counter value to determine the
   breakpoint that should be used */
extern breakpoint_from_pc_fn breakpoint_from_pc;
#undef  BREAKPOINT_FROM_PC
#define BREAKPOINT_FROM_PC(pcptr, lenptr) breakpoint_from_pc (pcptr, lenptr)

#undef SKIP_TRAMPOLINE_CODE
extern CORE_ADDR skip_trampoline_code (CORE_ADDR pc);
#define	SKIP_TRAMPOLINE_CODE(pc) skip_trampoline_code (pc)

#undef IN_SIGTRAMP
extern int in_sigtramp (CORE_ADDR pc, char *func_name);
#define IN_SIGTRAMP(pc,func_name) in_sigtramp(pc,func_name)

#define CANNOT_FETCH_REGISTER(regno) ((regno) == MQ_REGNUM)
#define CANNOT_STORE_REGISTER(regno) ((regno) == MQ_REGNUM)

/* Return the name of register number REG.  This may return "" to
   indicate a register number that's not used on this variant.
   (Register numbers may be sparse for consistency between variants.)  */
extern char *ppc_register_name (int reg);
#undef  REGISTER_NAME
#define REGISTER_NAME(reg) (ppc_register_name(reg))

/* Linux doesn't use the PowerOpen ABI for function pointer representation */
#undef CONVERT_FROM_FUNC_PTR_ADDR

#undef INIT_EXTRA_FRAME_INFO(fromleaf, fi)
#define	INIT_EXTRA_FRAME_INFO(fromleaf, fi)	\
	init_extra_frame_info (fromleaf, fi)
extern void init_extra_frame_info ();

extern void frame_init_saved_regs PARAMS ((struct frame_info *));
#undef  FRAME_INIT_SAVED_REGS
#define FRAME_INIT_SAVED_REGS(FI) frame_init_saved_regs (FI)

extern CORE_ADDR frame_args_address PARAMS ((struct frame_info *));
#undef  FRAME_ARGS_ADDRESS
#define FRAME_ARGS_ADDRESS(FI) frame_args_address (FI)

#undef INIT_FRAME_PC_FIRST
#define INIT_FRAME_PC_FIRST(fromleaf, prev) \
  	init_frame_pc_first(fromleaf, prev)

#if 0 /* If skip_prologue() isn't too greedy, we don't need this */
/* There is some problem with the debugging symbols generated by the
   compiler such that the debugging symbol for the first line of a
   function overlap with the function prologue.  */
#define PROLOGUE_FIRSTLINE_OVERLAP
#endif


/* CALL_DUMMY: This sequence of words is the instructions:

	mflr	r0		// 0x7c0802a6
				// save fpr's
	stfd	r?, num(r1)	// 0xd8010000 there should be 32 of this??
				// save gpr's
	stm	r0, num(r1)	// 0xbc010000
	stu	r1, num(r1)	// 0x94210000

				// load absolute address 0x12345678 to r0
	liu	r0, 0x1234	// 0x3c001234
	oril	r0, r0,0x5678	// 0x60005678
	mtctr	r0		// 0x7c0903a6 ctr <- r0
	bctrl			// 0x4e800421 jump subroutine 0x12345678 (%ctr)
	cror	0xf, 0xf, 0xf	// 0x4def7b82
	brpt			// 0x7d821008, breakpoint
	cror	0xf, 0xf, 0xf	// 0x4def7b82 (for 8 byte alignment)


  We actually start executing by loading function address first, since
  the pushing of the registers is done by PUSH_DUMMY_FRAME.  If this
  were real code, the arguments for the function called by the `bctrl'
  would be pushed between the `stu' and the `bctrl', and we could
  allow it to execute through.  But the arguments have to be pushed by
  GDB after the PUSH_DUMMY_FRAME is done, and we cannot allow to push
  the registers again.
*/
	
#undef CALL_DUMMY
#define CALL_DUMMY {0x7c0802a6, 0xd8010000, 0xbc010000, 0x94210000, \
		    0x3c001234, 0x60005678, 0x7c0903a6, 0x4e800421, \
		    0x4def7b82, 0x7d821008, 0x4def7b82 }


/* keep this as multiple of 8 (%sp requires 8 byte alignment) */
#undef CALL_DUMMY_LENGTH
#define CALL_DUMMY_LENGTH 44

#undef CALL_DUMMY_START_OFFSET
#define CALL_DUMMY_START_OFFSET 16

#undef FIX_CALL_DUMMY
#define FIX_CALL_DUMMY(dummyname, pc, fun, nargs, args, type, gcc_p) \
  ppclinux_fix_call_dummy (dummyname, pc, fun, nargs, args, type, gcc_p)
extern void ppclinux_fix_call_dummy PARAMS ((char *, CORE_ADDR, CORE_ADDR,
					   int, struct value **,
					   struct type *, int));

#endif  /* #ifndef TM_LINUX_H */
