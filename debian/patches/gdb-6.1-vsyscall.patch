Index: gdb-6.1/gdb/config/tm-linux.h
===================================================================
--- gdb-6.1.orig/gdb/config/tm-linux.h	2004-04-05 13:29:49.000000000 -0400
+++ gdb-6.1/gdb/config/tm-linux.h	2004-04-05 13:31:18.000000000 -0400
@@ -40,3 +40,6 @@
 
 #define SVR4_SHARED_LIBS
 #include "solib.h"		/* Support for shared libraries. */
+
+#define ADD_SYSINFO_SYMBOLS() linux_add_sysinfo_symbols ()
+void linux_add_sysinfo_symbols (void);
Index: gdb-6.1/gdb/corelow.c
===================================================================
--- gdb-6.1.orig/gdb/corelow.c	2004-04-05 13:31:18.000000000 -0400
+++ gdb-6.1/gdb/corelow.c	2004-04-05 13:31:18.000000000 -0400
@@ -397,6 +397,10 @@ core_open (char *filename, int from_tty)
 		"you won't be able to access this core file until you terminate\n\
 your %s; do ``info files''", target_longname);
     }
+
+#ifdef ADD_SYSINFO_SYMBOLS
+  ADD_SYSINFO_SYMBOLS ();
+#endif
 }
 
 static void
Index: gdb-6.1/gdb/linux-nat.c
===================================================================
--- gdb-6.1.orig/gdb/linux-nat.c	2004-04-05 13:29:49.000000000 -0400
+++ gdb-6.1/gdb/linux-nat.c	2004-04-05 13:31:18.000000000 -0400
@@ -238,12 +238,14 @@ void
 child_post_attach (int pid)
 {
   linux_enable_event_reporting (pid_to_ptid (pid));
+  linux_add_sysinfo_symbols ();
 }
 
 void
 linux_child_post_startup_inferior (ptid_t ptid)
 {
   linux_enable_event_reporting (ptid);
+  linux_add_sysinfo_symbols ();
 }
 
 #ifndef LINUX_CHILD_POST_STARTUP_INFERIOR
Index: gdb-6.1/gdb/linux-proc.c
===================================================================
--- gdb-6.1.orig/gdb/linux-proc.c	2004-04-05 13:29:49.000000000 -0400
+++ gdb-6.1/gdb/linux-proc.c	2004-04-05 13:59:17.000000000 -0400
@@ -34,6 +34,7 @@
 #include "elf-bfd.h"		/* for elfcore_write_* */
 #include "cli/cli-decode.h"	/* for add_info */
 #include "gdb_string.h"
+#include "symfile.h"
 
 #include <signal.h>
 
@@ -735,3 +736,18 @@ linux_proc_pending_signals (int pid, sig
 
   fclose (procfile);
 }
+
+void
+linux_add_sysinfo_symbols (void)
+{
+  bfd *templ_bfd = exec_bfd ? exec_bfd : core_bfd;
+  CORE_ADDR val;
+
+  if (target_auxv_search (&current_target, AT_SYSINFO_EHDR, &val) <= 0)
+    return;
+
+  if (val == 0)
+    return;
+
+  symbol_file_add_from_memory (templ_bfd, val, 0);
+}
Index: gdb-6.1/gdb/remote.c
===================================================================
--- gdb-6.1.orig/gdb/remote.c	2004-04-05 13:29:49.000000000 -0400
+++ gdb-6.1/gdb/remote.c	2004-04-05 13:31:18.000000000 -0400
@@ -2290,6 +2290,10 @@ remote_open_1 (char *name, int from_tty,
       remote_check_symbols (symfile_objfile);
     }
 #endif
+
+#ifdef ADD_SYSINFO_SYMBOLS
+  ADD_SYSINFO_SYMBOLS ();
+#endif
 }
 
 /* This takes a program previously attached to and detaches it.  After
Index: gdb-6.1/gdb/symfile.c
===================================================================
--- gdb-6.1.orig/gdb/symfile.c	2004-04-05 13:29:49.000000000 -0400
+++ gdb-6.1/gdb/symfile.c	2004-04-05 13:31:18.000000000 -0400
@@ -764,6 +764,10 @@ new_symfile_objfile (struct objfile *obj
    NAME is the file name (which will be tilde-expanded and made
    absolute herein) (but we don't free or modify NAME itself).
 
+   If ABFD is not null, it's already open and should be used instead of
+   opening the file by name.  This BFD will be closed on error, and
+   is always consumed by this function.
+
    FROM_TTY says how verbose to be.
 
    MAINLINE specifies whether this is the main symbol file, or whether
@@ -776,7 +780,7 @@ new_symfile_objfile (struct objfile *obj
    Upon success, returns a pointer to the objfile that was added.
    Upon failure, jumps back to command level (never returns). */
 static struct objfile *
-symbol_file_add_with_addrs_or_offsets (char *name, int from_tty,
+symbol_file_add_with_addrs_or_offsets (char *name, bfd *abfd, int from_tty,
                                        struct section_addr_info *addrs,
                                        struct section_offsets *offsets,
                                        int num_offsets,
@@ -785,14 +789,16 @@ symbol_file_add_with_addrs_or_offsets (c
   struct objfile *objfile;
   struct partial_symtab *psymtab;
   char *debugfile;
-  bfd *abfd;
   struct section_addr_info *orig_addrs;
   struct cleanup *my_cleanups;
 
   /* Open a bfd for the file, and give user a chance to burp if we'd be
      interactively wiping out any existing symbols.  */
 
-  abfd = symfile_bfd_open (name);
+  if (abfd == NULL)
+    abfd = symfile_bfd_open (name);
+
+  my_cleanups = make_cleanup_bfd_close (abfd);
 
   if ((have_full_symbols () || have_partial_symbols ())
       && mainline
@@ -801,6 +807,7 @@ symbol_file_add_with_addrs_or_offsets (c
     error ("Not confirmed.");
 
   objfile = allocate_objfile (abfd, flags);
+  discard_cleanups (my_cleanups);
 
   orig_addrs = alloc_section_addr_info (bfd_count_sections (abfd));
   my_cleanups = make_cleanup (xfree, orig_addrs);
@@ -917,7 +924,8 @@ struct objfile *
 symbol_file_add (char *name, int from_tty, struct section_addr_info *addrs,
 		 int mainline, int flags)
 {
-  return symbol_file_add_with_addrs_or_offsets (name, from_tty, addrs, 0, 0, 
+  return symbol_file_add_with_addrs_or_offsets (name, NULL, from_tty,
+						addrs, 0, 0,
                                                 mainline, flags);
 }
 
@@ -1767,6 +1775,106 @@ add_shared_symbol_files_command (char *a
 #endif
 }
 
+/* Helper function passed to bfd_map_over_sections.  */
+static void
+build_addr_info (bfd *abfd, asection *sectp, void *info)
+{
+  struct section_addr_info *const sai = info;
+  unsigned int i = 0;
+
+  if ((bfd_get_section_flags (abfd, sectp) & (SEC_ALLOC|SEC_LOAD)) == 0)
+    return;
+
+  while (sai->other[i++].name != NULL)
+    if (i == sai->num_sections)
+      return;
+
+  sai->other[i].addr = bfd_get_section_vma (abfd, sectp);
+  sai->other[i].name = (char *) bfd_get_section_name (abfd, sectp);
+  sai->other[i].sectindex = sectp->index;
+}
+
+/* Read inferior memory at ADDR to find the header of a loaded object file
+   and read its in-core symbols out of inferior memory.  TEMPL is a bfd
+   representing the target's format.  */
+struct objfile *
+symbol_file_add_from_memory (bfd *templ, CORE_ADDR addr, int from_tty)
+{
+  struct objfile *objf;
+  bfd *nbfd;
+  bfd_vma loadbase;
+  struct section_addr_info *sai;
+  unsigned int i;
+
+  if (from_tty)
+    {
+      if (bfd_get_flavour (templ) != bfd_target_elf_flavour)
+	error ("add-symbol-file-from-memory not supported for this target");
+    }
+  else
+    gdb_assert (bfd_get_flavour (templ) == bfd_target_elf_flavour);
+
+  nbfd = bfd_elf_bfd_from_remote_memory (templ, addr, &loadbase,
+					 target_read_memory);
+  if (nbfd == NULL)
+    {
+      if (from_tty)
+	error ("Failed to read a valid object file image from memory.");
+      return NULL;
+    }
+
+  nbfd->filename = xstrdup ("shared object read from target memory");
+
+  if (!bfd_check_format (nbfd, bfd_object))
+    {
+      /* FIXME: should be checking for errors from bfd_close (for one thing,
+         on error it does not free all the storage associated with the
+         bfd).  */
+      bfd_close (nbfd);
+      if (from_tty)
+	error ("Got object file from memory but can't read symbols: %s.",
+	       bfd_errmsg (bfd_get_error ()));
+      return NULL;
+    }
+
+  sai = alloc_section_addr_info (bfd_count_sections (nbfd));
+  make_cleanup (xfree, sai);
+  bfd_map_over_sections (nbfd, build_addr_info, sai);
+  for (i = 0; i < sai->num_sections && sai->other[i].name != NULL; ++i)
+    sai->other[i].addr += loadbase;
+
+  objf = symbol_file_add_with_addrs_or_offsets ((char *) nbfd->filename, nbfd,
+						from_tty, sai, NULL, 0, 0,
+						OBJF_SHARED);
+
+  reinit_frame_cache ();	/* ??? */
+
+  return objf;
+}
+
+static void
+add_symbol_file_from_memory_command (char *args, int from_tty)
+{
+  CORE_ADDR addr;
+  bfd *templ;
+
+  if (args == NULL)
+    error ("add-symbol-file-from-memory requires an expression argument");
+
+  addr = parse_and_eval_address (args);
+
+  /* We need some representative bfd to know the target we are looking at.  */
+  if (symfile_objfile != NULL)
+    templ = symfile_objfile->obfd;
+  else
+    templ = exec_bfd;
+  if (templ == NULL)
+    error ("\
+Must use symbol-file or exec-file before add-symbol-file-from-memory.");
+
+  (void) symbol_file_add_from_memory (templ, addr, from_tty);
+}
+
 /* Re-read symbols if a symbol-file has changed.  */
 void
 reread_symbols (void)
@@ -2023,7 +2131,7 @@ reread_separate_symbols (struct objfile 
          Preserve the flags from objfile that make sense.  */
       objfile->separate_debug_objfile
         = (symbol_file_add_with_addrs_or_offsets
-           (debug_file,
+           (debug_file, NULL,
             info_verbose, /* from_tty: Don't override the default. */
             0, /* No addr table.  */
             objfile->section_offsets, objfile->num_sections,
@@ -3526,6 +3634,13 @@ with the text.  SECT is a section name t
 	       &cmdlist);
   set_cmd_completer (c, filename_completer);
 
+  c = add_cmd ("add-symbol-file-from-memory", class_files,
+	       add_symbol_file_from_memory_command,
+	       "Usage: add-symbol-file-from-memory ADDR\n\
+Load the symbols out of memory from a dynamically loaded object file.\n\
+ADDR is the starting address of the file's shared object file header.",
+	       &cmdlist);
+
   c = add_cmd ("add-shared-symbol-files", class_files,
 	       add_shared_symbol_files_command,
    "Load the symbols from shared objects in the dynamic linker's link map.",
Index: gdb-6.1/gdb/symfile.h
===================================================================
--- gdb-6.1.orig/gdb/symfile.h	2004-04-05 13:29:49.000000000 -0400
+++ gdb-6.1/gdb/symfile.h	2004-04-05 13:31:18.000000000 -0400
@@ -302,6 +302,12 @@ extern CORE_ADDR symbol_overlayed_addres
 /* Load symbols from a file.  */
 extern void symbol_file_add_main (char *args, int from_tty);
 
+/* Read inferior memory at ADDR to find the header of a loaded object file
+   and read its in-core symbols out of inferior memory.  TEMPL is a bfd
+   representing the target's format.  */
+extern struct objfile *symbol_file_add_from_memory (bfd *templ, CORE_ADDR addr,
+						    int from_tty);
+
 /* Clear GDB symbol tables.  */
 extern void symbol_file_clear (int from_tty);
 
