Status: submitted similar patch 2004-12-08

This patch cleans up the initialization of thread_db.  It works for static
binaries now.  The vsyscall patches hide this problem, since new static
binaries will load the vsyscall DSO and then trigger thread_db; but
this is still a good cleanup.

Index: gdb-6.3.90.20051119/gdb/linux-thread-db.c
===================================================================
--- gdb-6.3.90.20051119.orig/gdb/linux-thread-db.c	2005-10-13 05:31:59.000000000 -0400
+++ gdb-6.3.90.20051119/gdb/linux-thread-db.c	2005-11-19 15:15:55.000000000 -0500
@@ -37,6 +37,7 @@
 #include "regcache.h"
 #include "solib-svr4.h"
 #include "gdbcore.h"
+#include "observer.h"
 
 #ifdef HAVE_GNU_LIBC_VERSION_H
 #include <gnu/libc-version.h>
@@ -626,59 +627,49 @@ check_thread_signals (void)
 #endif
 }
 
+/* Check whether thread_db is usable.  This function is called when
+   an inferior is created (or otherwise acquired, e.g. attached to)
+   and when new shared libraries are loaded into a running process.  */
+
 static void
-thread_db_new_objfile (struct objfile *objfile)
+check_for_thread_db (void)
 {
   td_err_e err;
+  static int already_loaded;
 
   /* First time through, report that libthread_db was successfuly
      loaded.  Can't print this in in thread_db_load as, at that stage,
-     the interpreter and it's console haven't started.  The real
-     problem here is that libthread_db is loaded too early - it should
-     only be loaded when there is a program to debug.  */
-  {
-    static int dejavu;
-    if (!dejavu)
-      {
-	Dl_info info;
-	const char *library = NULL;
-	/* Try dladdr.  */
-	if (dladdr ((*td_ta_new_p), &info) != 0)
-	  library = info.dli_fname;
-	/* Try dlinfo?  */
-	if (library == NULL)
-	  /* Paranoid - don't let a NULL path slip through.  */
-	  library = LIBTHREAD_DB_SO;
-	printf_unfiltered (_("Using host libthread_db library \"%s\".\n"),
-			   library);
-	dejavu = 1;
-      }
-  }
+     the interpreter and it's console haven't started.  */
 
-  /* Don't attempt to use thread_db on targets which can not run
-     (core files).  */
-  if (objfile == NULL || !target_has_execution)
+  if (!already_loaded)
     {
-      /* All symbols have been discarded.  If the thread_db target is
-         active, deactivate it now.  */
-      if (using_thread_db)
-	{
-	  gdb_assert (proc_handle.pid == 0);
-	  unpush_target (&thread_db_ops);
-	  using_thread_db = 0;
-	}
+      Dl_info info;
+      const char *library = NULL;
+      if (dladdr ((*td_ta_new_p), &info) != 0)
+	library = info.dli_fname;
+
+      /* Try dlinfo?  */
 
-      goto quit;
+      if (library == NULL)
+	/* Paranoid - don't let a NULL path slip through.  */
+	library = LIBTHREAD_DB_SO;
+
+      printf_unfiltered (_("Using host libthread_db library \"%s\".\n"),
+			 library);
+      already_loaded = 1;
     }
 
   if (using_thread_db)
     /* Nothing to do.  The thread library was already detected and the
        target vector was already activated.  */
-    goto quit;
+    return;
+
+  /* Don't attempt to use thread_db on targets which can not run
+     (executables not running yet, core files) for now.  */
+  if (!target_has_execution)
+    return;
 
-  /* Initialize the structure that identifies the child process.  Note
-     that at this point there is no guarantee that we actually have a
-     child process.  */
+  /* Initialize the structure that identifies the child process.  */
   proc_handle.pid = GET_PID (inferior_ptid);
 
   /* Now attempt to open a connection to the thread library.  */
@@ -705,12 +696,24 @@ thread_db_new_objfile (struct objfile *o
 	       thread_db_err_str (err));
       break;
     }
+}
+
+static void
+thread_db_new_objfile (struct objfile *objfile)
+{
+  if (objfile != NULL)
+    check_for_thread_db ();
 
-quit:
   if (target_new_objfile_chain)
     target_new_objfile_chain (objfile);
 }
 
+static void
+check_for_thread_db_observer (struct target_ops *target, int from_tty)
+{
+  check_for_thread_db ();
+}
+
 /* Attach to a new thread.  This function is called when we receive a
    TD_CREATE event or when we iterate over all threads and find one
    that wasn't already in our list.  */
@@ -1336,5 +1339,8 @@ _initialize_thread_db (void)
       /* Add ourselves to objfile event chain.  */
       target_new_objfile_chain = deprecated_target_new_objfile_hook;
       deprecated_target_new_objfile_hook = thread_db_new_objfile;
+
+      /* Register ourselves for the new inferior observer.  */
+      observer_attach_inferior_created (check_for_thread_db_observer);
     }
 }
Index: gdb-6.3.90.20051119/gdb/Makefile.in
===================================================================
--- gdb-6.3.90.20051119.orig/gdb/Makefile.in	2005-11-19 15:11:23.000000000 -0500
+++ gdb-6.3.90.20051119/gdb/Makefile.in	2005-11-19 15:13:21.000000000 -0500
@@ -2189,7 +2189,7 @@ linux-nat.o: linux-nat.c $(defs_h) $(inf
 linux-thread-db.o: linux-thread-db.c $(defs_h) $(gdb_assert_h) \
 	$(gdb_proc_service_h) $(gdb_thread_db_h) $(bfd_h) $(exceptions_h) \
 	$(gdbthread_h) $(inferior_h) $(symfile_h) $(objfiles_h) $(target_h) \
-	$(regcache_h) $(solib_svr4_h) $(gdbcore_h)
+	$(regcache_h) $(solib_svr4_h) $(gdbcore_h) $(observer_h)
 lynx-nat.o: lynx-nat.c $(defs_h) $(frame_h) $(inferior_h) $(target_h) \
 	$(gdbcore_h) $(regcache_h)
 m2-exp.o: m2-exp.c $(defs_h) $(gdb_string_h) $(expression_h) $(language_h) \
